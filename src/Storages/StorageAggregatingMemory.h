#pragma once

#include <atomic>
#include <optional>
#include <mutex>

#include <ext/shared_ptr_helper.h>

#include <Core/NamesAndTypes.h>
#include <Interpreters/Aggregator.h>
#include <Interpreters/ExpressionAnalyzer.h>
#include <Processors/QueryPipeline.h>
#include <Processors/Transforms/AggregatingTransform.h>
#include <Storages/IStorage.h>
#include <DataStreams/IBlockOutputStream.h>

namespace DB
{

/** Special storage, allows incremental data aggregation in memory.
  * Creates and stores all the data in the Aggregator,
  * allowing reads and writes to it.
  */
class StorageAggregatingMemory final : public ext::shared_ptr_helper<StorageAggregatingMemory>, public IStorage
{
friend class AggregatingOutputStream;
friend struct ext::shared_ptr_helper<StorageAggregatingMemory>;

public:
    String getName() const override { return "AggregatingMemory"; }

    Pipe read(
        const Names & column_names,
        const StorageMetadataPtr & /*metadata_snapshot*/,
        SelectQueryInfo & query_info,
        ContextPtr context,
        QueryProcessingStage::Enum processed_stage,
        size_t max_block_size,
        unsigned num_streams) override;

    /// Smaller blocks (e.g. 64K rows) are better for CPU cache.
    bool prefersLargeBlocks() const override { return false; }

    bool noPushingToViews() const override { return true; }

    BlockOutputStreamPtr write(const ASTPtr & query, const StorageMetadataPtr & metadata_snapshot, ContextPtr context) override;

    void drop() override;

    void truncate(const ASTPtr &, const StorageMetadataPtr &, ContextPtr, TableExclusiveLockHolder &) override;

    void startup() override;

    // TODO implement totalRows and totalBytes using data from Aggregator (if possible)
    // std::optional<UInt64> totalRows(const Settings &) const override;
    // std::optional<UInt64> totalBytes(const Settings &) const override;

private:
    mutable std::mutex mutex;

    SelectQueryDescription select_query;
    ContextPtr constructor_context;
    ConstraintsDescription constructor_constraints;

    Block src_block_header;
    StorageMetadataPtr src_metadata_snapshot;

    AggregatingTransformParamsPtr aggregator_transform;

    std::unique_ptr<SelectQueryExpressionAnalyzer> query_analyzer;
    ExpressionAnalysisResult analysis_result;

    std::shared_ptr<ManyAggregatedData> many_data;

protected:
    StorageAggregatingMemory(const StorageID & table_id_, ConstraintsDescription constraints_, const ASTCreateQuery & query, ContextPtr context_);
};

}
